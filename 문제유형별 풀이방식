1. DFS
    - 한가지 정점과 연결된 모든 정점을 탐색해야하는 경우
    - 경로를 찾아야 되는 경우
    - 사이클이 존재하는 경로를 찾는 경우

    # 1. 탐색 시작 노드를 스택에 삽입하고 방문처리
    # 2. 스택 최상단 노드에 방문하지 않은 인접노드가 있으면 스택에 넣고 방문처리
         방문하지 않은 인접노드가 없으면 스택에서 최상단 노드 꺼내 pop()
    # 3. 스택이 빌때까지 반복

2. BFS
    - 최단거리 구하는 경우
    - 최단거리를 구하되 조건이 여러개 존재하는 경우

    # 1. 탐색 시작 노드를 큐에 삽입하고 방문처리
    # 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드 모!두!를 큐에 삽입하고 방문처리
    # 3. 큐가 빌때까지 반복

3. 선택정렬
    가장 작은 데이터를 선택해 가장 앞에 있는 데이터와 바꿈
4. 삽입정렬
    - 데이터가 거의 정렬되어 있을 때는 가장 효율적임
    - 두번째 데이터부터 시작! (첫번째 데이터는 그 자체로 이미 정렬되어 있다고 판단)
5. 퀵정렬
    - 피벗 설정(첫번째 데이터) 후 왼쪽에서부터는 피벗보다 큰 데이터, 오른쪽에서부터는 피벗보다 작은 데이터 찾아 서로 교환
    - 만약 찾은 값의 위치가 서로 엇갈린 경우, 작은데이터와 피벗의 위치를 변경
    - 피벗을 기준으로 분할 완료!
    - 분할된 파티션에서도 각각 퀵정렬 실행

6. 계수정렬
    - 데이터의 크기 범위가 제한적이고, 정수형태의 데이터인 경우 사용
    - 데이터의 크기가 많이 중복되어 있을 수록 유리 , 1000만개 미만의 데이터
    - 가장 큰 데이터와 가장 작으 데이터의 범위가 모두 담길 수 있는 하나의 리스트 생성

7. 완전탐색 (순차탐색 ): 80%의 문제가 완전탐색으로 풀림
    - 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용


8. 이진 탐색
    - 전제조건: 정렬되어 있는 상
    - 먼저 정렬되어 있는지 확인하고 정렬되어 있지 않다면 정렬을 먼저 수행
    - 문제에서 구하라고 하는 값의 범위를 고려해서 탐색범위를 절반으로 좁혀가며 탐색














5. 크루스칼 알고리즘 : N개의 노드로 이루어진 그래프가 주어졌을때, N-1개의 간선을 이용한 최소신장트리 구하기
    1) 간선들을 모두 오름차순 정렬
    2) 가중치가 가장 작은 간선부터 선택하면서 사이클일 생기지 않는 경우 해당 간선 선택
    3) N-1개의 간선이 선택될때 까지 반복



6. 다익스트라 알고리즘 : 한 시작 지점에서 모든 노드까지의 최단거리 구하기