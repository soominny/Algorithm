1. DFS
    - 한가지 정점과 연결된 모든 정점을 탐색해야하는 경우
    - 경로를 찾아야 되는 경우
    - 사이클이 존재하는 경로를 찾는 경우

    # 1. 탐색 시작 노드를 스택에 삽입하고 방문처리
    # 2. 스택 최상단 노드에 방문하지 않은 인접노드가 있으면 스택에 넣고 방문처리
         방문하지 않은 인접노드가 없으면 스택에서 최상단 노드 꺼내 pop()
    # 3. 스택이 빌때까지 반복

2. BFS
    - 최단거리 구하는 경우
    - 최단거리를 구하되 조건이 여러개 존재하는 경우

    # 1. 탐색 시작 노드를 큐에 삽입하고 방문처리
    # 2. 큐에서 노드를 꺼내 해당 노드의 인접 노드 중 방문하지 않은 노드 모!두!를 큐에 삽입하고 방문처리
    # 3. 큐가 빌때까지 반복

3. 선택정렬
    가장 작은 데이터를 선택해 가장 앞에 있는 데이터와 바꿈
4. 삽입정렬
    - 데이터가 거의 정렬되어 있을 때는 가장 효율적임
    - 두번째 데이터부터 시작! (첫번째 데이터는 그 자체로 이미 정렬되어 있다고 판단)
5. 퀵정렬
    - 피벗 설정(첫번째 데이터) 후 왼쪽에서부터는 피벗보다 큰 데이터, 오른쪽에서부터는 피벗보다 작은 데이터 찾아 서로 교환
    - 만약 찾은 값의 위치가 서로 엇갈린 경우, 작은데이터와 피벗의 위치를 변경
    - 피벗을 기준으로 분할 완료!
    - 분할된 파티션에서도 각각 퀵정렬 실행

6. 계수정렬
    - 데이터의 크기 범위가 제한적이고, 정수형태의 데이터인 경우 사용
    - 데이터의 크기가 많이 중복되어 있을 수록 유리 , 1000만개 미만의 데이터
    - 가장 큰 데이터와 가장 작으 데이터의 범위가 모두 담길 수 있는 하나의 리스트 생성

7. 완전탐색 (순차탐색 ): 80%의 문제가 완전탐색으로 풀림
    - 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용


8. 이진 탐색
    - 전제조건: 정렬되어 있는 상태
    - 먼저 정렬되어 있는지 확인하고 정렬되어 있지 않다면 정렬을 먼저 수행
    - 문제에서 구하라고 하는 값의 범위를 고려해서 탐색범위를 절반으로 좁혀가며 탐색


9. 다익스트라 알고리즘 : 특정한 한 노드에서 출발하여 다른 노드로 최단경로
    1) 출발노드를 제외한 나나머지 노드의 최단거리는 INF (int(1e9))로 설정
        출발노드의 최단거리는 0으로 설정.
    2) 우선순위 큐에서 원소 하나를 꺼내서 방문한적 있는 노드인 경우 무시.
        방문하지 않은 노드인 경우, 그 노드를 걸쳐서 갈 수 있는 노드의 최소비용 계산
    3) 갱신된 노드와 거리정보는 우선순위 큐에 넣기

10. 플로이드 워셜 알고리즘 : 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구하는 경우
    - 3중 for문


11. 서로소 집합
    1) def find_parent
    2) def union_parent
    3) 사이클이 생기지 않는다면 (루트 노드가 같지 않다면) 합치기.

12. 크루스칼 알고리즘
    - 모든 간선에 대하여 cost를 기준으로 정렬을 수행 후 !
    - 가장 거리(cost)가 작은거 부터 사이클을 발생시키지 않는 것은 신장트리에 추가

13. 위상정렬
    1) 진입차수 0인 노드를 큐에 넣기
    2) 큐가 빌때까지 큐에서 하나씩 꺼내서 해당노드에서 출발하는 간선 제거, 진입차수 갱신















5. 크루스칼 알고리즘 : N개의 노드로 이루어진 그래프가 주어졌을때, N-1개의 간선을 이용한 최소신장트리 구하기
    1) 간선들을 모두 오름차순 정렬
    2) 가중치가 가장 작은 간선부터 선택하면서 사이클일 생기지 않는 경우 해당 간선 선택
    3) N-1개의 간선이 선택될때 까지 반복

